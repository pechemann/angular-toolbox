<!--
 * LICENSE
 * Copyright Pascal ECHEMANN. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://pascalechemann.com/angular-toolbox/resources/license
-->

<nav class="page-menu col-xl-3 ps-4">
    <aside class="w-100 mb-4">
        <h5 class="mb-4">In this topic</h5>
        <ul class="list-group">
            <li class="list-group-item active" aria-current="true">
                Presentation
            </li>
            <li class="list-group-item"><a href="javascript:appBridge.navigate(['resources/documentation/logging-framework','api'])">
                API</a>
            </li>
        </ul>
    </aside>
    <section class="w-100">
        <h5 class="mb-4">On this page</h5>
        <ul class="list-group">
            <li class="list-group-item"><a href="#presentation" onclick="appBridge.goToAnchor(event)" title="Presentation">Presentation</a></li>
            <li class="list-group-item"><a href="#principles" onclick="appBridge.goToAnchor(event)" title="Principles">Principles</a></li>
            <li class="list-group-item"><a href="#sample" onclick="appBridge.goToAnchor(event)" title="Principles">Real Life Example</a></li>
        </ul>
    </section>
</nav>

<header class="fs-5 col-xl-9 mb-4">
    <h2 class="mb-3">Angular Toolbox Logging Framework</h2>
    <p>
        The <em class="lib-name">ATX Logging Framework</em> provides an easy-to-use and highly configurable
        solution to add a logging system to your Angular libraries and applications.
    </p>
    <small>Since <span class="badge text-bg-warning rounded-pill">v 0.12.0</span></small>
    <hr class="mt-4">
</header>

<section class="col-xl-9" id="presentation">
    <h3>Presentation</h3>
    <p>
        Work in progress...
    </p>
</section>


<section class="col-xl-9" id="principles">
    <h3>Principles</h3>
    <p>
        The philosophy of the <em class="lib-name">ATX Logging Framework</em> is mainly
        based around two interfaces, which allow to clearly separate concerns:
    </p>
    <ul>
        <li><code>Logger</code>: responsible for managing and transmitting logs to log connectors</li>
        <li><code>LogConnector</code> responsible for processing logs transmitted by the logger</li>
    </ul>
    <p>
        The <code>Logger</code> interface provides a high-level implementation through the service
        <code>LoggerService</code> class. If needed, Developers can create specific implementations,
        simply by extending the <code>AbstractLogger</code> class (e.g. for creating API level loggers).
    </p>
    <p>
        The <code>LogConnector</code> interface allows you to define the behavior of logs based on the business of the application.
        For example, a connector could be responsible for sending error logs to the server while ignoring information logs.
    </p>
    <p>
        The <em class="lib-name">ATX Logging Framework</em> provides 3 implementations of the <code>LogConnector</code> interface.
    </p>
    <ul>
        <li><code>DefaultLogConnector</code>: does not perform any operation on the logs.
            It allows to make the log system silent again without having to modify the business code of the application.
            <em>(This is the default implementation.)</em>
        </li>
        <li><code>ConsoleLogConnector</code>: sends all logs to the JavaScript console.</em></li>
        <li><code>HtmlLogConnector</code>: sends all logs to the HTML element specified by the developer.
            Logs rendering is similar to a standard command console.
        </li>
    </ul>
    <p>
        This design guarantees both, great simplicity of use and unlimited flexibility.
        For example, you can to create a connector that instantiates other connectors, to perform differentiated processing.
        Such a model is much more efficient than a log engine based on collections of different stacked loggers.
    </p>
</section>


<section class="col-xl-9" id="sample">
    <h3>Real Life Example</h3>
    <p>
        Work in progress...
    </p>
</section>
<!--<section class="col-xl-9" id="mocking-api-calls">
    <h3>Mocking API Calls</h3>
    <p>
        API mocking is the creation of a simulated version of an API that mirrors the
        behaviour of an actual API.
    </p>
    <p>
        A common use case is where front-end developers need to create new features,
        based on backend APIs made by other development teams.
        This is a recurring problem that all Angular developers have to face!
    </p>
    <p>
        Ideally, the <em>data access layer</em> should never be changed when mocking APIs.
        It means that the URI endpoint in the following sample must not be modified during all developement process:
        <figure>
            <pre><code class="language-typescript">http.get<Config>('https://my-domain.com/api/data').subscribe(config => {
    // process the data.
});</code></pre></figure>
    </p>
    <p>
        You may argue that you can change a single URL, but what if several developers
        create different services in separated parts of an app?
        <br>
        Unfortunately, Angular does not offer a native solution to overcome this problem.
    </p>
    <p class="lead">
        This is where the <em>HTTP Mocking Framework</em> comes in!
    </p>
</section>
<section class="col-xl-9" id="keep-it-simple">
    <h3>Keep It Simple!</h3>
    <p>
        If you are familiar with developing <a href="nodejs.or" title="Node.js">Node.js</a> apps
        created with <a href="https://expressjs.com/" title=">Express.js">Express.js</a>,
        handling the <em>HTTP Mocking Framework</em> will be straightforward.
    </p>
    <p>
        The only difficulty is to correctly set URL patterns, as you usually do with the Angular router.
        <br>
        The following sample code shows how to write a basic config that will intercept all HTTP calls
        for URLs on the form <code>http://localhost:4200/todos/:id</code> with the <code>GET</code> method:
    </p>
    <figure>
        <pre><code class="language-typescript">const getTodo = (id: string) => { ... }
...
{
    route: "/todos/:id",
    get: {
        data: (req: HttpRequest<any>, params: any) => 
               httpResponseMock().body( getTodo(params.id) ).response();
    }
}</code></pre></figure>
</section>-->

<!-- We use a data object to store navigation tree structure-->
<object id="navigation-tree"
        data-tree="[{ 'label': 'ATX Logging Framework' }]">
</object>
